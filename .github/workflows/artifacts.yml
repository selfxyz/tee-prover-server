name: TEE Docker Build
on:
  workflow_call:
    inputs:
      environment:
        description: The GitHub Actions environment
        required: true
        type: string
      tag:
        description: The tag
        required: true
        type: string

jobs:
  prod:
    permissions:
      contents: read
      id-token: write
    runs-on: [self-hosted-gha]

    env:
      PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
      GAR_REGISTRY: us-docker.pkg.dev
      ARTIFACT_REPOSITORY: ${{ secrets.GCP_ARTIFACT_REPOSITORY }}
      ARTIFACT_URL: us-docker.pkg.dev/${{ secrets.GCP_PROJECT_ID }}/${{ secrets.GCP_ARTIFACT_REPOSITORY }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Authenticate to Google Cloud
        id: auth
        uses: google-github-actions/auth@v2
        with:
          token_format: access_token
          project_id: ${{ env.PROJECT_ID }}
          workload_identity_provider: ${{ secrets.GCP_WIF_PROVIDER }} # full resource path
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT_EMAIL }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          version: ">= 363.0.0"
          project_id: ${{ env.PROJECT_ID }}

      - name: Configure Docker for Artifact Registry
        run: |
          sudo usermod -aG docker ec2-user
          newgrp docker
          gcloud auth configure-docker ${{ env.GAR_REGISTRY }} --quiet

      - name: Install aws cli
        run: |
          if ! command -v aws &> /dev/null; then
            curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
            unzip awscliv2.zip
            sudo ./aws/install
          fi

      - name: Login to AWS
        run: |
          aws --profile default configure set aws_access_key_id ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws --profile default configure set aws_secret_access_key ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - name: Download and unpack artifact
        run: |
          curl -L \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer ${{ secrets.PAT_TOKEN }}" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            -o artifact.zip \
            https://api.github.com/repos/selfxyz/self/actions/artifacts/3424161964/zip

      - name: Sort circuits
        run: |
          unzip artifact.zip -d ./circuits/
          chmod +x sort_circuits.sh
          ./sort_circuits.sh

      - name: Download and unpack zkeys
        run: |
          rm -rf zkeys
          chmod +x download_zkeys.sh && ./download_zkeys.sh
          mkdir zkeys
          mv *.zkey zkeys/

      - name: Reformat zkeys
        run: |
          mkdir -p zkeys/register zkeys/disclose zkeys/dsc
          # mv zkeys/register_* zkeys/register/
          mv zkeys/vc_and_disclose*.zkey zkeys/disclose/
          # mv zkeys/dsc_* zkeys/dsc/
          chmod +x sort_zkeys.sh
          ./sort_zkeys.sh

      - name: Init submodules
        run: |
          git submodule update --init
          cd rapidsnark && git submodule update --init && cd ..

      - name: Build docker enclave images
        run: |
          echo "TAG='${{ inputs.tag }}'"
          echo "ARTIFACT_URL='${{ env.ARTIFACT_URL }}'"
          chmod +x ./build_docker.sh
          ./build_docker.sh ${{ env.ARTIFACT_URL }} ${{ inputs.tag }}

      - name: Cleanup zkeys
        run: rm -rf zkeys*

      - name: Push images
        run: |
          chmod +x push_docker.sh
          ./push_docker.sh ${{ env.ARTIFACT_URL }} ${{ inputs.tag }}

      - name: Setup tmate session
        uses: mxschmitt/action-tmate@v3
        timeout-minutes: 15
        with:
          limit-access-to-actor: true

      - name: Trigger Cloud Function (notify image publish)
        if: success()
        env:
          # HTTPS URL of your Cloud Function (Gen2), e.g. https://us-central1-<proj>.cloudfunctions.net/notifyImagePublish
          CF_URL: ${{ secrets.GCP_CF_URL }}
          # The same service account you use for WIF (must have Invoker on the function)
          SA_EMAIL: ${{ secrets.GCP_SERVICE_ACCOUNT_EMAIL }}
          TAG: ${{ inputs.tag }}
          ENVIRONMENT: ${{ inputs.environment }}
        run: |
          set -euo pipefail

          # Ensure jq is available (supports Amazon Linux or Ubuntu runners)
          if ! command -v jq >/dev/null 2>&1; then
            (sudo yum -y install jq || (sudo apt-get update && sudo apt-get install -y jq)) || {
              echo "jq not found and failed to install" >&2; exit 1;
            }
          fi

          # Ensure your push script created the digests file
          if [ ! -f pushed-image-digests.txt ]; then
            echo "pushed-image-digests.txt not found. Did push_docker.sh write it?" >&2
            exit 1
          fi

          # Convert newline-separated digests -> JSON array
          jq -R -s 'split("\n") | map(select(length>0))' pushed-image-digests.txt > digests.json

          # Build the payload your function expects
          PAYLOAD=$(jq -n \
            --arg tag "$TAG" \
            --arg env "$ENVIRONMENT" \
            --arg repo "${{ github.repository }}" \
            --arg sha "${{ github.sha }}" \
            --arg actor "${{ github.actor }}" \
            --slurpfile digests digests.json \
            '{tag:$tag, environment:$env, repository:$repo, sha:$sha, actor:$actor, image_digests:$digests[0]}')

          # Mint an ID token for the Cloud Function *via impersonation*
          # Prereqs:
          # - Your WIF principal has roles/iam.serviceAccountTokenCreator on $SA_EMAIL
          # - $SA_EMAIL has roles/run.invoker (or cloudfunctions.invoker) on the function
          IDTOKEN=$(gcloud auth print-identity-token $SA_EMAIL \
            --audiences="$CF_URL")

          # Invoke the Cloud Function
          curl -fsSL -X POST \
            -H "Authorization: Bearer $IDTOKEN" \
            -H "Content-Type: application/json" \
            -d "$PAYLOAD" \
            "$CF_URL"
